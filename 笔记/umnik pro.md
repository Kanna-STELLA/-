在我的辅导下学习时使用的其他提示，在这里。  
  
不要再关心评级了  
除非涉及到奖金，否则你在排行榜上的位置没有任何区别。如果我知道我还能再解决一个问题，我可以在赢得比赛后感觉很糟糕。或者我知道我解决了所有我能解决的问题，我也可以觉得失去一堆评分点也没关系。 因为评分只是一个数字。它是非常不稳定的，它取决于其他人，而不仅仅是你的技能。但解决问题完全取决于你。而且你对自己的评价不应基于一些随机的指标，而应基于你诚实的感觉，你的表现是否达到了你的期望。你的自我感觉应该在你的控制之下，不要纠结于一些假想的数值，你不能把你的进步降低到一个单一的数字。  
  
不要使用一个以上的账户  
评级只是一个数字。不要害怕失去你的颜色。如果你继续提高，你很快就会找回来。  
  
你也不需要用第二个账户来发垃圾信息。如果你认为你正在做的事情是狗屎，你不想让它与你的主账户联系起来，你根本就不应该这样做。要不就为你的嘲弄行为感到自豪（从你的主账户做起），要不就别做。  
  
写作比赛（咄）。  
你可能认为你还没有准备好写一些竞赛，你需要更多的练习来解决没有时间限制的问题。是的，练习是进步的必要部分，但如果不写竞赛，你将永远无法学会如何在压力下运作。学习如何做X的最好方法是尝试做X。  
  
删除评级预测器  
它的意义到底是什么？它能帮助你做出做什么的决定吗？要解决什么问题？要破解什么问题？不。它可能给你动力，但也可能通过给你一种虚假的安全感来破坏你的动力。  
  
此外，评级只是一个数字。你在比赛中的唯一目标应该是尽可能多地解决问题。越快越好，越好越好，而黑客攻击则是以后的事。专注于解决。专注于下一个问题。就是这样。回合只是一系列的间隔，在那里你专注于新的问题。  
  
==评级的随机性太大，不能与你的成就感联系起来。为自己解决了问题而感到骄傲，而不是为你的名次和评级变化而感到骄傲。  
  
撰写AtCoder  
不需要解释。只管去做。  
  
==不要把想法或算法强加给问题  ==
？？
基本上是这样： 关于 "这是贪婪还是DP"，强迫和橡皮筋  
  
你可以（也应该）尝试思考 "我可以做贪婪的吗？我可以做DP吗？"以及类似的问题。你不应该做的是相信这个问题必须用任何特定的算法来解决，并且只试图
想出一个方法来使这个特定的算法发挥作用。  
？？？

一个非常特殊的例子是，从约束条件和/或基础对象中猜测解决方案或复杂性。是的，知道哪种复杂度是预期的，这是有用的信息。但你不可能从约束条件中100%确定它，这并不能决定使用哪种算法。  
  
？？而且不要先选择算法，后解决问题。？？
算法是你用来有效实现解决方案的工具。如果有人请你帮忙组装家具，你不会不看手册就说 "我拿我的万能扳手，这就是我需要的"。当然，在解决问题方面也有很大的不同。首先，你没有手册，你应该自己写手册，这就叫解决问题。其次，你所有的工具箱都在你的脑子里，所以把整个工具箱带到问题上是不需要任何成本的。  
  
如果你不知道如何计算一个n<1000的查询的答案，就不要写一个段树  
. 在看到带内六角的螺丝之前，不要从工具箱中拿出你的六角扳手。  
  
### 向自己提出问题  
在阅读问题陈述时：  
  
	为什么这个限制会出现在这里？如果它不在这里，问题会有什么变化？  
	什么是不寻常的？  
	该问题要求我做什么？  
	我可以把它重新表述为某个标准问题吗？是对某个标准问题的发挥吗？是某个困难（可能是NP-complete）问题的特例吗？  
在解决这个问题的时候：  
  
	我将如何解决这个问题的一个更简单的版本？减少限制。将底层对象改为更简单的东西：[图]→[连接图]→[仙人掌]→[独轮车]→[树]→[竹/阵列]或[星]；[矩阵/网格]→[阵列]。是否有一些观察方法也适用于一般版本？  
	如何回答一个查询？  
	我将如何在纸上解决一个小案例？我将如何在没有时间或内存限制的情况下解决它？  
在实现这个问题之前：  
  
	复杂性是什么？  
	我对问题的理解是否正确？  
	我需要哪些功能？  
	哪些地方比较棘手？为了正确实现它们，我需要记住什么？  
	哪个地方的实现是最重的？我可以做得更简单吗？  
	哪个地方最慢？哪些地方我需要注意常数因素，哪些地方我可以选择更慢但更简单的实现？  
如果不是AC：  
  
	你是否记得做了所有的事情来处理你之前想到的那些棘手的地方？  
	解决方案是否正确？  
	我对问题的理解是否正确？  
如果你有一个测试，而解决方案给出了错误的答案：  
  
	解决方案是否做了它应该做的事？  
	问题是在代码中还是在想法中？  
	
如果样例测试不能找到反例测试：  

	我对问题的理解是否正确？  
	我的愚蠢的解决方案绝对是愚蠢的吗？它是否使用了主解决方案中的任何假设/观察？  
	我是否产生了所有可能的测试变体？该问题是否有多测试，如果有，我是否生成了多测试？  
在被接受之后：  
  
	我在哪些方面可以做得更好？  
	哪些方面花费的时间比我希望的要多？  
	是否有什么技巧可以简化实现？  
不要按题目解决  
甚至不要看问题标签。它们是破坏者，妨碍你的进展。  
  
**但是Um_nik，学习如何做X的最好方法就是做X。我想成为DP高手，因此我需要解决DP问题。  
  
**语句正确，结论错误。你想要擅长的不仅是解决DP问题，最重要的是识别DP问题。而当你按题目解决问题时，你总是跳过这一步。你立即从阅读一个问题到把它放在DP术语中，==你没有体验到问题可以作为DP来解决的意识，你没有获得这些问题在你头脑中如何呈现的知识。  ==
  
因此，当你在没有任何关于题目的提示的情况下解决问题时（例如，在竞赛设置中），你不知道如何迈出第一步，尽管你可能会做之后的一切。  
  
提升到你的下一个水平  
比方说，你想在这一轮比赛中能够解决ABC div2。那么，最好的办法就是一直解决ABC，但不一定要在这一轮中解决。颠覆性的解决! 你可以自己做，也可以和编辑一起做。==如果有一个难解的实现点你无法弄明白，可以试着去理解别人的代码来解决这个问题。  ==
  
这不是代替解决档案问题，而是补充。档案有很多问题（duh），而且大多数是旧的（duh）。这可能会刺激你跳过 "随机一半 "的问题，这实际上不是随机的，而是你潜意识中不喜欢的问题。通过上升解，你要确保你涵盖了在当前元数据中出现的主题。  
  
学习如何做X的最好方法是尝试做X。  
  
==不要试图创造那些必须有特定解决方案的问题。  ==
我不知道如何帮助你成为一个好的问题设置者。但我知道一件事。创造一个问题来适应一个解决方案并不意味着这个解决方案对问题来说是最佳的。你可能为一个问题创造了最复杂的数据结构，而这个问题最终可以用一个简单的贪婪法来解决。==如果你试图对你的问题施加限制以阻止简单的解决方案，你就会使你的问题变得更加丑陋，或者通过限制泄露你的解决方案。  
  
你仍然可以在任何地方找到灵感，从一个解决方案开始是初学者进入问题设置的好方法。这也是一种熟悉一些新课题的有趣方式，即使你最终没有得到任何实际问题，你仍然可以学到更多围绕类似设置的数学模型。但是，==如果你想出了问题，你应该立即忘记你的解决方案。好吧，你应该记住它，是的，但把它当作一个解决方案，而不是解决方案。它只是你的一些想法，但它可能不是解决你问题的最快或最漂亮的方法。  ==
  
[Translated with DeepL](https://www.deepl.com/translator?utm_source=windows&utm_medium=app&utm_campaign=windows-share)