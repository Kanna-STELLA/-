# a
在著名的测试系统MathForces上，抽出了n个  
评级单位被安排。评级将按照以下算法进行分配：如果k  
参与者参加这个活动，那么n 在抽签结束时，可能还剩下一个未使用的等级--它不会被给任何参与者。  
  
例如，如果n=5  
和k=3  
那么每个参与者将获得一个1  
评级单位，还有2  
评级单位将保持未使用。如果n=5  
，并且k=6  
，那么没有一个参与者会增加他们的评级。  
  
Vasya参加了这次评级抽奖，==但没有关于这次活动参与者总数的信息。==因此，他想知道这次抽奖的结果==可能得到哪些不同的评级增量值==，请你帮助。  
  
例如，如果n=5  
，那么答案就等于序列0,1,2,5  
. 每一个序列值（而且只有它们）都可以得到⌊n/k⌋  
对于某个正整数k  
(其中，⌊x⌋  
是x的值 四舍五入）： 0=⌊5/7⌋  
, 1=⌊5/5⌋  

, 2=⌊5/2⌋  
????
, 5=⌊5/1⌋  
.  
7  
7  
写一个程序，对于给定的n  
，找到所有可能的评级增量的序列。  
  
輸入  
第一行包含整数t  
(1≤t≤10  
)--输入的测试案例的数量。然后t  
测试用例。  
  
每一行包含一个整数n  
(1≤n≤109  
)--正在绘制的评级单元的总数。  
  
输出  
输出t个测试案例的答案  
测试案例的答案。每个答案应该包含在两行中。  
  
在第一行打印一个整数m  
- Vasya可以得到的不同评级增量值的数量。  
  
在下面一行中，打印m  
整数，按升序排列--可能的评级增量的值。  


朴素做法，
枚举n除1到n/2，没出现过的数就计数，遍历bool，输出出现过的。


n/2,没办法预处理。
%%有效的点i 从n/1跳到 n / 2 跳到 n / 3 跳到 n  / 4 跳到 n / n;%%






# b
 (1≤n≤2⋅105接下来的n
 行包含列表中的密码--非空字符串 si
的非空字符串，其长度最多为50
 字母。有些密码可能是相等的。
所有密码的总长度不超过106
 字母所有的密码都只由小写拉丁字母组成。
 
 在单行中打印最小数量的密码，使用这些密码可以保证进入系统。
 
 
 两个密码a和b是等价的，如果有一个字母，同时存在于a和b
有一个c和ab分别等价时，ab等价
如果在系统中设置了一个密码，并应用一个相等的密码来访问系统，那么用户就可以进入系统。

列表中只有一个密码是测试系统的管理员密码。帮助黑客计算出保证进入系统所需的最小密码数。请记住，黑客不知道系统中设置了哪些密码。

保证进入系统，就是
与密码条里的所有密码都等价的最小密码数。

用哈希来统计密码中的字符出现情况的话，
肯定越长越好，排序

如果全部出现过，就不计数？
没想法。。。。
最小生成树？
字符建边

# e
n * *有N个
 名程序员，你想把他们分成几个不空的小组。第i个程序员的技能是
-第一名程序员的技能是ai
. 你想从他们中组合出最大数量的团队。每个团队都有一个限制：团队中的程序员人数乘以团队中所有程序员的最低技能必须至少是x
.

每个程序员最多属于一个团队。有些程序员可能会被排除在团队之外。

计算你可以组建的最大团队数。

输入
第一行包含整数t
 (1≤t≤1000
)--测试用例的数量。

每个测试案例的第一行包含两个整数n
 和x
 (1≤n≤105;1≤x≤109
)--分别是程序员的数量和团队技能的限制。

每个测试用例的第二行包含n
 整数a1,a2,...,an
 (1≤ai≤109
)，其中ai
 是第i个程序员的技能
-第一名程序员的技能。

n的总和
 的总和不超过105
.

输出
为每个测试案例打印一个整数--你可以组建的最大团队数量。


 (1≤n≤105;1≤x≤109
 -分别是程序员的数量和团队技能的限制。
  (1≤ai≤109

n * min ai >= x
如果ai 是 二分之一 ，就不要了
强的和弱的组没有意义，强的能单人就直接单人。
然后强的不能单人时，看能不能找到弱一点的，双人。
人数++ *  弱的的分数
因为强的都不能单人了，那必定要找弱的组双人，然后一直找，找到满足条件了
就cnt++，人数改为1.
输出cnt
# k 
t
(3≤n≤109
Vova发现的糖果包装纸的数量。可以保证有一些正整数x
 和整数k>1
 
 打印一个整数 - x的任何正整数值
 所以有一个整数k>1
 即x+2x+4x+⋯+2k-1x=n
.

第k天买2的k-1次方 * x糖果

x和k 是正整数，而且k>1


给糖果总数，求x的值


1 2 4 8 16 32
等比数列前n项和

快速幂
预处理32位的n存bool
while k
k >>= 1;
if(k & 1) res = res * t;
t = t * t;


# H
H. lk学长说，这个问题有一些  
每次测试的时间限制1秒。  
每次测试的内存限制256 MB  
输入标准输入  
outputstandard output  
Shubham有一个二进制字符串s  
. 二进制字符串是一个只包含字符 "0 "和 "1 "的字符串。  
  
他可以对该字符串进行任意次数的以下操作：  
  
选择字符串的一个索引，并翻转该索引上的字符。这意味着，如果该字符是 "0"，它就变成了 "1"，反之亦然。  
如果一个字符串不包含 "010 "或 "101 "的子序列，则称为好字符串--例如，"1001 "包含 "101 "的子序列，因此它不是一个好字符串，而 "1000 "既不包含 "010 "也不包含 "101 "的子序列，所以它是一个好字符串。  
  
那么，他最少要进行多少次操作才能使该字符串成为好字符串？可以证明，通过这些操作，我们可以使任何字符串变得良好。  
  
一个字符串a  
是字符串b的一个子序列  
的子序列，如果a  
可以从b中得到  
删去几个（可能是零个或全部）字符，则一个字符串a是一个字符串b的子序列。  
  
输入  
输入的第一行包含一个整数t  
(1≤t≤100)  
- 测试案例的数量。  
  
接下来的t  
行都包含一个二进制字符串s  
(1≤|s|≤1000)  
.  
  
输出  
对于每一个字符串，输出使其成为好字符串所需的最小操作数。  
  
例子  
inputCopy  
7  
001  
100  
101  
010  
0  
1  
001100  
输出拷贝  
0  
0  
1  
1  
0  
0  
2  
备注  
在测试案例1  
, 2  
, 5  
, 6  
不需要任何操作，因为它们已经是好的字符串。  
  
对于第3  
rd测试案例： "001 "可以通过翻转第一个字符来实现--这是获得一个好字符串的可能方法之一。  
  
对于第4个  
第四个测试案例： "000 "可以通过翻转第二个字符来实现，也是获得一个好字符串的可能方式之一。  
  
对于第7  
第7个测试案例： "0000 "可以通过翻转第三和第四个字符来实现，这也是获得一个好字符串的可能方法之一。  
  
  
  
[Translated with DeepL](https://www.deepl.com/translator?utm_source=windows&utm_medium=app&utm_campaign=windows-share)
# C
输出标准输出  
凤凰网喜欢美丽的数组。如果一个数组中所有长度为k的子数组  
的子数都有相同的总和，那么这个数组就是美丽的。一个数组的子数组是任何连续元素的序列。  
  
凤凰网目前有一个数组a  
的长度为n  
. 他想在他的数组中插入一些整数，可能是零，这样它··就会变得很漂亮。插入的整数必须是在1  
和n  
包括在内。整数可以插入任何地方（甚至在第一个或最后一个元素之前或之后），而且他并不是要尽量减少插入的整数的数量。  
  
输入  
输入由多个测试案例组成。第一行包含一个整数t  
(1≤t≤50  
)--测试用例的数量。  
  
每个测试用例的第一行包含两个整数n  
和k  
(1≤k≤n≤100  
).  
  
每个测试用例的第二行包含n  
空间分隔的整数（1≤ai≤n  
)--Phoenix当前拥有的数组。这个数组可能是也可能不是已经很美。  
  
输出  
对于每个测试案例，如果不可能创建一个漂亮的数组，则打印-1。否则，打印两行。  
  
第一行应该包含美丽数组的长度m  
(n≤m≤104  
). 你不需要最小化m  
.  
  
第二行应该包含m  
空间分隔的整数（1≤bi≤n  
)--这是一个美丽的数组，Phoenix将一些可能为零的整数插入他的数组a后可以得到。  
. 你可以打印原本不在数组a中的整数  
.  
  
如果有多个解决方案，就打印任何一个。可以保证，如果我们能使数组a  
美丽，我们总能使它的结果长度不超过104  
.  
  
例子  
InputCopy  
4  
4 2  
1 2 2 1  
4 3  
1 2 2 1  
3 2  
1 2 3  
4 4  
4 3 4 2  
输出拷贝  
5  
1 2 1 2 1  
4  
1 2 2 1  
-1  
7  
4 3 2 1 4 3 2  
注意  
在第一个测试案例中，我们可以通过插入整数1来使数组a  
通过在索引3处插入整数1  
在索引3处  
(在现有的两个2之间)  
s). 现在，所有长度为k=2的子数组  
都有相同的和 3  
. 存在许多其他可能的解决方案，例如：  
  
2,1,2,1,2,1  
1,2,1,2,1,2  
在第二个测试案例中，数组已经非常漂亮：所有长度为k=3的子数组  
都有相同的和 5  
.  
  
在第三个测试案例中，我们可以证明，我们不能插入数字来使数组a  
美丽。  
  
在第四个测试案例中，数组b  
是美丽的，所有长度为k=4的子数组  
的所有子数都有相同的和 10  
. 也存在着其他的解决方案。  
  
[Translated with DeepL](https://www.deepl.com/translator?utm_source=windows&utm_medium=app&utm_campaign=windows-share)
# F
在约翰尼最喜欢的竞争性节目平台上举行的最后一次比赛得到了相当积极的反应。然而，约翰尼的评分又下降了！他认为所提出的任务很可爱，但没有显示出竞争对手的真实水平！他认为，提出的任务很可爱，但没有显示出竞争对手技能的真相。  
  
这个男孩现在正在看以二进制系统写的连续参与者的评分。他认为，这种评分差异越大，这些人挨在一起就越不公平。他把两个数字之间的差异定义为比特位置的数量，其中一个数字是0，另一个是1（我们假设数字的前导零填充到相同长度）。例如，5=1012的差异  
和14=11102  
相当于3  
，因为0101  
和1110  
差异在3  
位。约翰尼将比赛的不公平性定义为相邻参与者的这种差异的总和。  
  
约翰尼刚刚把评级序列发给你，希望你能找出比赛的不公平性。你已经注意到，你有一个连续的整数序列，从0  
到n  
. 这很奇怪，但这个男孩固执地说一切都对。所以请帮助他，为收到的数字找到所需的不公平。  
  
输入  
输入由多个测试案例组成。第一行包含一个整数t  
(1≤t≤10000  
)--测试案例的数量。下面的t  
行包含测试用例的描述。  
  
每个测试用例的第一行也是唯一一行包含一个整数n  
(1≤n≤1018)  
.  
  
输出  
输出t  
行。对于每个测试案例，你应该输出一个整数的单行--如果评级序列等于0，则比赛的不公平性。  
, 1  
, ..., n-1  
, n  
.  
  
例子  
输入复制  
5  
5  
7  
11  
1  
2000000000000  
输出拷贝  
8  
11  
19  
1  
3999999999987  
注  
对于n=5  
我们计算以下序列的不公平性（数字从0  
到5  
用二进制写，有额外的前导零，所以它们都有相同的长度）：  
  
000  
001  
010  
011  
100  
101  
差异等于1  
, 2  
, 1  
, 3  
, 1  
分别，所以不公平性等于1+2+1+3+1=8  
.  
  
[Translated with DeepL](https://www.deepl.com/translator?utm_source=windows&utm_medium=app&utm_campaign=windows-share)
 (1≤t≤10000 (1≤n≤1018)
  行。对于每个测试案例，你应该输出一个整数的单行--比赛的不公平性。如果评级序列等于0，
  这个男孩现在正在看以二进制系统写的连续参与者的评分。他认为，这种评分差异越大，这些人挨在一起就越不公平。他把两个数字之间的差异定义为比特位置的数量，其中一个数字是0，另一个是1（我们假设数字的前导零填充到相同长度）。例如，5=1012的差异
 和14=11102
 相当于3
，因为0101
 和1110
 差异在3
 
 
 约翰尼将比赛的不公平性定义为相邻参与者的这种差异的总和。
 异或之后枚举二进制数位看是否是1？
 但是1e18的数据总不能两两枚举。


1 + 2 + 1 + 3 + 1离线打表看看没发现什么特别的
# G
给你一个数组a
 的n个
 元素的数组。

你可以执行以下操作，但不超过n
 次： 选择三个指数x,y,z
 (1≤x<y<z≤n)
 并将ax
 替换为 ay-az
. 操作后，|ax|
 需要小于1018
.

你的目标是使得到的数组不递减。如果有多种解决方案，你可以输出任何一种。如果不可能实现，你也应该报告。

输入
每个测试包含多个测试案例。第一行将包含一个单一的整数t
 (1≤t≤10000)
 - 测试用例的数量。然后t
 个测试用例紧随其后。

每个测试用例的第一行包含一个单一的整数n
 (3≤n≤2⋅105)
 - 数组的大小a
.

每个测试用例的第二行包含n
 整数a1,a2,...,an
 (-109≤ai≤109)
的元素，a
.

可以保证所有测试用例的n之和
 之和不超过2⋅105。
.

输出
对于每个测试案例，如果没有解决方案，则打印-1
 如果没有解决方案，则打印一行。否则应在第一行打印一个整数m
 (0≤m≤n)
 - 你所执行的操作的数量。

然后，下面的第i
-行中的第i
 行应该包含三个整数x、y、z
 (1≤x<y<z≤n)
- 对第i
-的操作。

如果有多个解决方案，你可以输出任何一个。请注意，在这个任务中，你不需要将操作的数量降到最低。

例子
输入复制
3
5
5 -4 2 -1 2
3
4 3 2
3
-3 -2 -1
输出拷贝
2
1 2 3
3 4 5
-1
0
注意
在第一个例子中，数组变成

[-6,-4,2,-1,2]
 在第一次操作之后、

[-6,-4,-3,-1,2]
 在第二次操作后变成[-6,-4,-3,-1,2]。

在第二个例子中，不可能在任何操作序列后使数组排序。

在第三个例子中，数组已经被排序，所以我们不需要进行任何操作。


# I
激光枪是一种团队射击游戏，玩家试图通过用激光发射枪标记其他个人来射击他们。

阿里和雷斯利决定进行一场比赛，因此他们各自召集了一个由n名队员组成的团队。
 队员。

举行比赛的竞技场是一个N×N的
 2d
 平面，Resli队的第
 Resli队的第1名队员将站在坐标(i,0)处。
，而阿里队的第
 而阿里队的第1名球员将站在坐标(i,N)处。
.

为了增加挑战性，竞技场有Q
 墙，每面墙都平行于X轴，由三个整数x1,x2,y给出
 这意味着墙在点（x1,y）和（x2,y）之间延伸
 和(x2,y)之间
.

为了确保他的胜利，Resli修改了他的团队的枪，当激光束击中某个墙时，光束会停止，并在墙的端点产生两个新的光束（在坐标(x1,y)
 和(x2,y)
 如果这些新产生的激光束中的一束击中墙壁，前面提到的过程将再次发生（见说明）。

你能不能帮助雷斯利找出，如果雷斯利队的每个队员都朝平行于y轴的方向向对面的队员发射一束激光，那么阿里队有多少队员会被至少一束激光击中？
 阿里队的第1名队员将向第1名队员的方向射出一束激光。
 阿里队的第1名队员将向第1名队员发射一束激光）。

输入
第一行包含一个整数T
 (1≤T≤104
)，即测试案例的数量。

每个测试案例的第一行包含两个整数n
 (2≤n≤2×105
)和q
 (1≤q≤n
).

接下来的q
 行都包含三个整数 x1
,x2
,y
 (1≤x1≤x2≤n
), (1≤y≤n-1
)，这意味着在坐标(x1,y)和(x2,y)之间有一个墙。
 和(x2,y)之间有一堵墙
.

所有测试案例的n之和
 之和不会超过2×105。
.

保证没有两面墙会重叠或共享一个公共点。
输出
输出T
 行，其中第
 行包含第1个测试案例的答案。
 测试案例的答案。

例子
inputCopy
1
5 4
1 4 1
4 5 2
2 3 3
3 5 4
输出拷贝
3
注意
这张图展示了激光束的移动情况，假设每队有5个人，只有Resli队的第三个人射出激光，而且(1,1)之间有墙。
 人，只有Resli队的第三个人要发射激光，而且在（1,1）和（4,1）之间有一堵墙
 和(4,1)之间有一堵墙
. 激光将向阿里队的第三个人移动，在撞到墙和墙的端点（1,1）处的两个新激光后停止。
, (4,1)
 将被产生，并继续向阿里队的第一和第四人移动。


# J


